# sample
X = c(3.66, 1.00, -0.87, 2.90, -0.80,
3.20, 1.69, -3.53, 3.22, 3.53)
# sample
x = c(3.66, 1.00, -0.87, 2.90, -0.80,
3.20, 1.69, -3.53, 3.22, 3.53)
sample(1:length(x))
# sample
x = c(3.66, 1.00, -0.87, 2.90, -0.80,
3.20, 1.69, -3.53, 3.22, 3.53)
sample(1:length(x), replace = TRUE)
sample(1:length(x), replace = TRUE)
sample(1:length(x), replace = TRUE)
sample(x, replace = TRUE)
set.seed(1)
M = 10000
N = 10
X = matrix(data = NA, nrow = M, ncol = N)
data = NA, nrow = M, ncol = N)
set.seed(1)
for(jDraw in 1:M){
X[,jDraw] = sample(x, replace = TRUE)
}
set.seed(1)
for(jDraw in 1:M){
X[,jDraw] = sample(x, replace = TRUE)
}
X[,jDraw]
jDraw
jDraw
dim(X)
set.seed(1)
for(jDraw in 1:M){
X[jDraw,] = sample(x, replace = TRUE)
}
X
muHatVec = mean(X)
muHatVec
muHatVec = rowMeans(X)
muHatVec
M
install.packages('KernSmooth')
install.packages(moments)
install.packages('moments')
install.packages('pracma')
library(KernSmooth)
library(moments)
library(pracma)
sample <- c(3.66,1.00,-0.87,2.90,-0.80,3.20,1.69,-3.53,3.22,3.53)
samplemean <- mean(sample)
ndraws = 1000
meanb <- rep(NA, ndraws)
stdb  <- rep(NA, ndraws)
# 1a) Estimate the pdf of the sample mean and the st.dev. of the sample mean
for (iter in c(1:ndraws)) {
sampling    <- sample.int(length(sample), 10,
replace = TRUE)   # Sample with replacement
bootsample  <- sample[sampling]             # extract bootstrapped sample
meanb[iter] <- mean(bootsample)             # compute the mean
}
print(paste0("The Standard Deviation of the mean is ", round(sd(meanb),3)))
plot(bkde(meanb),
xlab = "sample mean",
ylab = "pdf",
main = "Kernel Density Estimate of Bootstrapped Sample Mean")
#lines(y)
abline(v = c(samplemean,median(meanb)),
col = c("blue","red"),
lty = c(2,2))
legend(-1.75, 0.5,
legend=c("Estimated Mean", "Median Bootstrap Mean"),
col=c("blue", "red"),
lty=2:2,
cex=0.8,
box.lty=0)
print(paste0("The skewness of the bootstrap distribution is:",
round(skewness(meanb),3)," (<0 left, >0 right"))
lb_asy <- samplemean - qnorm(0.975)*sd(meanb)
ub_asy <- samplemean + qnorm(0.975)*sd(meanb)
# Percentile Bootstrap CI
bounds <- quantile(meanb, probs = c(0.025,0.975))
# Flipped
aux1 <- abs(bounds[1] - samplemean)
aux2 <- abs(bounds[2] - samplemean)
flipped <- c(samplemean - aux2,samplemean + aux1)
print(paste0("The asymptotic confidence interval is: [",
round(lb_asy,3),",",
round(ub_asy,3),"]" ))
print(paste0("The percentile bootstrap confidence interval is: [",
round(bounds[1],3),",",
round(bounds[2],3),"]" ))
print(paste0("The flipped bootstrap confidence interval is: [",
round(flipped[1],3),",",
round(flipped[2],3),"]" ))
install.packages('steadyICA')
library('steadyICA')
S
T
T = 200
n = 3
S = mvrnorm(T, rep(0, n), diag(3))
# simulation_steadyICA.R  Validate size of the permTest() procedure
# Preliminaries ----
library('steadyICA')
library('MASS')
library('parallel')
S = mvrnorm(T, rep(0, n), diag(3))
S
shocks^2
S^2
corr_shocks_sq = corr(S^2)
corr_shocks_sq = cor(S^2)
corr_shocks_sq
corr_shocks_sq
ncol(S)
n              = ncol(S)
corr_shocks_sq = cor(S^2)
teststat      = sqrt((sum(as.vector(corr_shocks_sq)^2)-n)/(n^2-n))  # Root mean squared off-diagonal correlation
teststat
corTestStat = function(S){
n              = ncol(S)
corr_shocks_sq = cor(S^2)
teststat       = sqrt((sum(as.vector(corr_shocks_sq)^2)-n)/(n^2-n))  # Root mean squared off-diagonal correlation
return(teststat)
}
teststat = corTestStat(S)
teststat
teststat = corTestStat(S)
teststat
Sboot = rep(NA, ncol= ncol(S), nrow = nrow(S))
Sboot
nrow(S)
ncol(S)
Sboot = rep(NA, ncol= ncol(S), nrow = nrow(S))
Sboot
Sboot = matrix(rep(NA, ncol(S)*nrow(S)), nrow = nrow(S))
Sboot
sample.int(nrow(S), replace = TRUE)
length(unique(sample.int(nrow(S), replace = TRUE)))
table(sample.int(nrow(S), replace = TRUE))
Sboot = matrix(rep(NA, ncol(S)*nrow(S)), nrow = nrow(S))
for(j in 1:3){
Sboot[,j] = S[sample.int(nrow(S), replace = TRUE), j]
}
Sboot
teststat_boot = corTestStat(Sboot)
corTestBoot = function(S, numboot){
teststat = corTestStat(S)
Sboot = matrix(rep(NA, ncol(S)*nrow(S)), nrow = nrow(S))
# Draw independently across columns
for(j in 1:3){
Sboot[,j] = S[sample.int(nrow(S), replace = TRUE), j]
}
teststat_boot = corTestStat(Sboot)
return(teststat_boot)
}
sapply(corTestBoot, numboot)
crossCorTest.boot(S)
crossCorTest.stat = function(S){
n              = ncol(S)
corr_shocks_sq = cor(S^2)
teststat       = sqrt((sum(as.vector(corr_shocks_sq)^2)-n)/(n^2-n))  # Root mean squared off-diagonal correlation
return(teststat)
}
crossCorTest.boot = function(S){
teststat = crossCorTest.stat(S)
Sboot = matrix(rep(NA, ncol(S)*nrow(S)), nrow = nrow(S))
# Draw independently across columns
for(j in 1:3){
Sboot[,j] = S[sample.int(nrow(S), replace = TRUE), j]
}
teststat_boot = crossCorTest.stat(Sboot)
return(teststat_boot)
}
teststatVec = sapply(1:numboot, crossCorTest.boot(S))
crossCorTest.boot = function(S){
teststat = crossCorTest.stat(S)
Sboot = matrix(rep(NA, ncol(S)*nrow(S)), nrow = nrow(S))
# Draw independently across columns
for(j in 1:3){
Sboot[,j] = S[sample.int(nrow(S), replace = TRUE), j]
}
teststat_boot = crossCorTest.stat(Sboot)
return(teststat_boot)
}
teststatVec = sapply(1:numboot, crossCorTest.boot(S))
teststatVec = sapply(1:numboot, function(x) crossCorTest.boot(S))
numboot=10
teststatVec = sapply(1:numboot, function(x) crossCorTest.boot(S))
teststatVec
teststatBoot = sapply(1:numboot, function(x) crossCorTest.boot(S))
teststat > teststatBoot
teststat
teststatBoot
S
S = mvrnorm(T, rep(0, n), diag(3))
teststat = crossCorTest.stat(S)
teststat
teststatBoot = sapply(1:numboot, function(x) crossCorTest.boot(S))
teststatBoot
teststat > teststatBoot
p = teststat > teststatBoot
p
mean(p)
numboot=1000
teststat = crossCorTest.stat(S)
teststatBoot = sapply(1:numboot, function(x) crossCorTest.boot(S))
p = teststat > teststatBoot
p = mean(teststat > teststatBoot)
p
crossCorTest = function(S, numboot){
teststat = crossCorTest.stat(S)
teststatBoot = sapply(1:numboot, function(x) crossCorTest.boot(S))
p = mean(teststat > teststatBoot)
return(p)
}
# Run simulation with permutation test
runSim = function(type, T, n, R=199, numboot = 2000){
S     = simS(type, T, n)
pPerm = permTest(S, group = 1:n, R, FUN = 'gmultidcov',
symmetric = FALSE, alpha=1)
pCrossCor = crossCorTest(S, numboot)
return(c(pPerm = pPerm), pCrossCor)
}
# Make AR1
genAR1 = function(T, n, rho){
S     = matrix(rep(NA, T*n), nrow = T)
S0    = rep(0, n)
S[1,] = rho * S0 + rnorm(n)
for(t in 2:T){
S[t,] = rho*S[t-1,] + rnorm(n)
}
return(S)
}
crossCorTest.stat = function(S){
n              = ncol(S)
corr_shocks_sq = cor(S^2)
teststat       = sqrt((sum(as.vector(corr_shocks_sq)^2)-n)/(n^2-n))  # Root mean squared off-diagonal correlation
return(teststat)
}
crossCorTest.boot = function(S){
Sboot = matrix(rep(NA, ncol(S)*nrow(S)), nrow = nrow(S))
# Draw independently across columns
for(j in 1:3){
Sboot[,j] = S[sample.int(nrow(S), replace = TRUE), j]
}
teststat_boot = crossCorTest.stat(Sboot)
return(teststat_boot)
}
crossCorTest = function(S, numboot){
teststat = crossCorTest.stat(S)
teststatBoot = sapply(1:numboot, function(x) crossCorTest.boot(S))
p = mean(teststat > teststatBoot)
return(p)
}
jRes = 1
nSim=10
type                 = Results[[jRes]]$type
# simulation_steadyICA.R  Validate size of the permTest() procedure
# Preliminaries ----
library('steadyICA')
library('MASS')
library('parallel')
set.seed(2021)
# On Della
setwd("/scratch/gpfs/eyqian/empirical")
T    = 200
n    = 3
nSim = 5000
pMat = NA
# Main ----
# Set settings
Results      = list()
Results[[1]] = list(type='normal', T=T, n=3, nSim=nSim,      pMat = pMat)
Results[[2]] = list(type='t, 2', T=T, n=3, nSim=nSim,        pMat = pMat)
Results[[3]] = list(type='t, 1', T=T, n=3, nSim=nSim,        pMat = pMat)
Results[[4]] = list(type='AR(1), 0.9', T=T, n=3, nSim=nSim,  pMat = pMat)
Results[[5]] = list(type='AR(1), 0.5', T=T, n=3, nSim=nSim,  pMat = pMat)
Results[[6]] = list(type='AR(1), 0.1', T=T, n=3, nSim=nSim,  pMat = pMat)
type                 = Results[[jRes]]$type
nSim                 = Results[[jRes]]$nSim
nSim
nSim = 10
pMat                 = unlist(mclapply(1:nSim, function(x) runSim(type, T, n)))
pMat                 = unlist(lapply(1:nSim, function(x) runSim(type, T, n)))
# Simulate shock matrix
simS = function(type, T, n)
{
if(type == 'normal') {
S = mvrnorm(T, rep(0, n), diag(3))
} else if(type == 't, 2'){
S = matrix(rt(3*T, 2), ncol=3)
} else if(type == 't, 1'){
S = matrix(rt(3*T, 1), ncol=3)
} else if (type == 'AR(1), 0.9'){
S     = genAR1(T, n, 0.9)
} else if (type == 'AR(1), 0.5'){
S     = genAR1(T, n, 0.5)
} else if (type == 'AR(1), 0.1'){
S     = genAR1(T, n, 0.1)
} else{
stop('Enter valid type')
}
return(S)
}
# Run simulation with permutation test
runSim = function(type, T, n, R=199, numboot = 2000){
S     = simS(type, T, n)
pPerm = permTest(S, group = 1:n, R, FUN = 'gmultidcov',
symmetric = FALSE, alpha=1)
pCrossCor = crossCorTest(S, numboot)
return(c(pPerm = pPerm), pCrossCor)
}
# Make AR1
genAR1 = function(T, n, rho){
S     = matrix(rep(NA, T*n), nrow = T)
S0    = rep(0, n)
S[1,] = rho * S0 + rnorm(n)
for(t in 2:T){
S[t,] = rho*S[t-1,] + rnorm(n)
}
return(S)
}
crossCorTest.stat = function(S){
n              = ncol(S)
corr_shocks_sq = cor(S^2)
teststat       = sqrt((sum(as.vector(corr_shocks_sq)^2)-n)/(n^2-n))  # Root mean squared off-diagonal correlation
return(teststat)
}
crossCorTest.boot = function(S){
Sboot = matrix(rep(NA, ncol(S)*nrow(S)), nrow = nrow(S))
# Draw independently across columns
for(j in 1:3){
Sboot[,j] = S[sample.int(nrow(S), replace = TRUE), j]
}
teststat_boot = crossCorTest.stat(Sboot)
return(teststat_boot)
}
crossCorTest = function(S, numboot){
teststat = crossCorTest.stat(S)
teststatBoot = sapply(1:numboot, function(x) crossCorTest.boot(S))
p = mean(teststat > teststatBoot)
return(p)
}
pMat                 = unlist(lapply(1:nSim, function(x) runSim(type, T, n)))
runSim(type, T, n)
runSim(type, T, n)
# Run simulation with permutation test
runSim = function(type, T, n, R=199, numboot = 2000){
S     = simS(type, T, n)
pPerm = permTest(S, group = 1:n, R, FUN = 'gmultidcov',
symmetric = FALSE, alpha=1)
pCrossCor = crossCorTest(S, numboot)
return(c(pPerm = pPerm, pCrossCor = pCrossCor))
}
runSim(type, T, n)
pMat                 = unlist(lapply(1:nSim, function(x) runSim(type, T, n)))
pMat
pMat                 = unlist(mclapply(1:nSim, function(x) runSim(type, T, n)))
pMat
matrix(pMat, nrow = nSim, byrow = TRUE)
temp   = lapply(Results, function(x) x$pMat)
temp
nSim = 50
#for(jRes in 1:length(Results))
for(jRes in 1:6)
{
type                 = Results[[jRes]]$type
nSim                 = Results[[jRes]]$nSim
pMat                 = unlist(mclapply(1:nSim, function(x) runSim(type, T, n)))
Results[[jRes]]$pMat = matrix(pMat, nrow = nSim, byrow = TRUE)
}
runSim = function(type, T, n, R=199, numboot = 500){
S     = simS(type, T, n)
pPerm = permTest(S, group = 1:n, R, FUN = 'gmultidcov',
symmetric = FALSE, alpha=1)
pCrossCor = crossCorTest(S, numboot)
return(c(pPerm = pPerm, pCrossCor = pCrossCor))
}
nSim
nSim = 50
for(jRes in 1:6)
{
type                 = Results[[jRes]]$type
nSim                 = Results[[jRes]]$nSim
pMat                 = unlist(mclapply(1:nSim, function(x) runSim(type, T, n)))
Results[[jRes]]$pMat = matrix(pMat, nrow = nSim, byrow = TRUE)
}
nSim = 50
# Run simulation with permutation test
runSim = function(type, T, n, R=199, numboot = 1000){
S     = simS(type, T, n)
pPerm = permTest(S, group = 1:n, R, FUN = 'gmultidcov',
symmetric = FALSE, alpha=1)
pCrossCor = crossCorTest(S, numboot)
return(c(pPerm = pPerm, pCrossCor = pCrossCor))
}
library('steadyICA')
library('MASS')
library('parallel')
set.seed(2021)
# On Della
setwd("/scratch/gpfs/eyqian/empirical")
T    = 200
n    = 3
nSim = 50
pMat = NA
# Main ----
# Set settings
Results      = list()
Results[[1]] = list(type='normal', T=T, n=3, nSim=nSim,      pMat = pMat)
Results[[2]] = list(type='t, 2', T=T, n=3, nSim=nSim,        pMat = pMat)
Results[[3]] = list(type='t, 1', T=T, n=3, nSim=nSim,        pMat = pMat)
Results[[4]] = list(type='AR(1), 0.9', T=T, n=3, nSim=nSim,  pMat = pMat)
Results[[5]] = list(type='AR(1), 0.5', T=T, n=3, nSim=nSim,  pMat = pMat)
Results[[6]] = list(type='AR(1), 0.1', T=T, n=3, nSim=nSim,  pMat = pMat)
ptm = proc.time()
#for(jRes in 1:length(Results))
for(jRes in 1:6)
{
type                 = Results[[jRes]]$type
nSim                 = Results[[jRes]]$nSim
pMat                 = unlist(mclapply(1:nSim, function(x) runSim(type, T, n)))
Results[[jRes]]$pMat = matrix(pMat, nrow = nSim, byrow = TRUE)
}
time = proc.time() - ptm
temp   = lapply(Results, function(x) x$pMat[1,])
pVal   = matrix(unlist(temp), ncol = length(Results))
header = unlist(lapply(Results, function(x) x$type))
print(header)
print(colSums(pVal < .1)/nSim)
write.table(pVal, 'pVals_simulation_steadyICA.csv', col.names=header, row.names = FALSE)
save.image(file='Results_simulation_steadyICA.RData')
# Functions ----
# Simulate shock matrix
simS = function(type, T, n)
{
if(type == 'normal') {
S = mvrnorm(T, rep(0, n), diag(3))
} else if(type == 't, 2'){
S = matrix(rt(3*T, 2), ncol=3)
} else if(type == 't, 1'){
S = matrix(rt(3*T, 1), ncol=3)
} else if (type == 'AR(1), 0.9'){
S     = genAR1(T, n, 0.9)
} else if (type == 'AR(1), 0.5'){
S     = genAR1(T, n, 0.5)
} else if (type == 'AR(1), 0.1'){
S     = genAR1(T, n, 0.1)
} else{
stop('Enter valid type')
}
return(S)
}
temp   = lapply(Results, function(x) x$pMat[1,])
pVal   = matrix(unlist(temp), ncol = length(Results))
header = unlist(lapply(Results, function(x) x$type))
print(header)
print(colSums(pVal < .1)/nSim)
pVal
nSim
Results[[1]]$pMat
temp   = lapply(Results, function(x) x$pMat[,1])
pVal   = matrix(unlist(temp), ncol = length(Results))
header = unlist(lapply(Results, function(x) x$type))
print(header)
print(colSums(pVal < .1)/nSim)
temp   = lapply(Results, function(x) x$pMat[,2])
pVal   = matrix(unlist(temp), ncol = length(Results))
header = unlist(lapply(Results, function(x) x$type))
print(header)
print(colSums(pVal < .1)/nSim)
S
chol(S)
chol(var(S))
t(chol(var(S)))
whiten.chol = function(x){
P = t(chol(var(x)))
return(t(solve(P) %*% t(x)))
}
setwd("~/GitHub/higher_moments/empirical")
var(S)
n
out        = as.data.frame(sapply(Results, function(x) x$type))
names(out) = 'type'
out$pPerm  = sapply(Results, function(x) x$pPerm)
# Preliminaries ----
library('steadyICA')
library('readxl')
set.seed(2021)
# Settings
n = 3
R = 5000  # Number of permutations
# Read shocks, from ICA procedure
shockPath = 'figures2019/initSetting=GlobalSearch_shocks.xls'
sheets    = excel_sheets(shockPath)
# Store results
Results = list()
for(jSheet in 1:length(sheets)){  # Loop through each sheet
# Read shocks
shocks = read_excel(shockPath, sheet = sheets[jSheet])
S      = as.matrix( shocks[,2:4])
pPerm = permTest(S, group = 1:n, R, FUN = 'gmultidcov',
symmetric = FALSE, alpha=1)
# Store results
Results[[jSheet]] = list(shocks = shocks, S = S, pPerm = pPerm, type = sheets[jSheet])
}
# Store output
out        = as.data.frame(sapply(Results, function(x) x$type))
names(out) = 'type'
out$pPerm  = sapply(Results, function(x) x$pPerm)
write.csv(out, 'figures2019/initSetting=GlobalSearch_shocksPermTest.csv')
